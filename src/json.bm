
' Internal types

Type jsontok
    typ As _Byte
    primType As _Byte

    ' Value can either be embedded in the 'value' field, or indexes into the
    ' original string
    value As _Mem

    ' Index into original json string
    startIdx As Long
    endIdx As Long

    ' Index of parent token.
    ' If token is FREE, then this is the index next free token
    '
    ' Note that ParentIdx is not filled-in for manually created tokens, so it
    ' should not be relied upon.
    ParentIdx As Long

    ' Array of Long's indicating indxes of child tokens
    ChildrenIdxs As _Mem
End Type

Type JsonTokenBlock
    m As _Mem
End Type

Sub ___JsonResetError()
    JsonHadError = JSON_ERR_SUCCESS
    JsonError = ""
End Sub

Sub JsonInit(json As Json)
    ___JsonResetError

    json.RootToken = 0
    json.TotalTokens = 0
    json.TotalBlocks = 0
    json.NextFree = -1

    ' Dummy _Mem, makes things a bit easier since there is no NULL
    json.TokenBlocks = _MemNew(1)

    json.IsInitialized = -1
End Sub

Sub JsonClear(json As Json)
    Dim b As JsonTokenBlock, i As Long
    ___JsonResetError

    For i = 0 To json.TotalBlocks - 1
        _MemGet json.TokenBlocks, json.TokenBlocks.OFFSET + i * Len(b), b

        JsonTokenBlockClear b
    Next

    _MemFree json.TokenBlocks
    json.IsInitialized = 0
End Sub

' Initializes a new JsonTokenBlock, including the space for tokens and free list 
'
' blockIdx is this block's index in the block list
' FIXME: PRIVATE
Sub JsonTokenBlockInit(b As JsonTokenBlock, blockIdxCpy As Long, nextFree As Long)
    Dim i As Long, tokCount As Long, t As jsontok, blockIdx As Long

    tokCount = _Shl(1, JSON_BLOCK_SHIFT)
    blockIdx = _Shl(blockIdxCpy, JSON_BLOCK_SHIFT)

    ' Don't need to zero it, as we're going to _MemPut the zero'd jsontok into
    ' it anyway
    b.m = _MemNew(tokCount * Len(t))

    For i = tokCount - 1 To 0 Step -1
        t.ParentIdx = nextFree

        _MemPut b.m, b.m.OFFSET + i * Len(t), t

        nextFree = blockIdx Or i
    Next
End Sub

' FIXME: PRIVATE
Sub JsonTokenBlockClear(b As JsonTokenBlock)
    Dim i As Long, t As jsontok, count As Long

    count = _Shl(1, JSON_BLOCK_SHIFT)

    For i = 0 To count - 1
        _MemGet b.m, b.m.OFFSET + i * Len(t), t
        JsonTokenClear t
    Next

    _MemFree b.m
End Sub

' FIXME: PRIVATE
Sub JsonTokenClear(t As jsontok)
    If t.value.OFFSET <> 0 Then _MemFree t.value
    If t.ChildrenIdxs.OFFSET <> 0 Then _MemFree t.ChildrenIdxs
End Sub

' FIXME: PRIVATE
Sub JsonTokenAddChild(t As jsontok, child As Long)
    Dim m As _Mem, childCount As _Offset

    If t.ChildrenIdxs.OFFSET <> 0 Then
        childCount = t.ChildrenIdxs.SIZE / 4 + 1

        m = _MemNew(childCount * Len(child))
        _MemCopy t.ChildrenIdxs, t.ChildrenIdxs.OFFSET, t.ChildrenIdxs.SIZE To m, m.OFFSET
        _memFree t.ChildrenIdxs

        _MemPut m, m.OFFSET + (childCount - 1) * Len(child), child
        t.ChildrenIdxs = m
    Else
        t.ChildrenIdxs = _MemNew(Len(child))

        _MemPut t.ChildrenIdxs, t.ChildrenIdxs.OFFSET, child
    End If
End Sub

' FIXME: PRIVATE
Function ___JsonTokenGetChild&(t As jsontok, idx As _Offset)
    Dim l As Long
    ___JsonTokenGetChild& = _MemGet(t.ChildrenIdxs, t.ChildrenIdxs.OFFSET + idx * Len(l), Long)
End Function

' FIXME: PRIVATE
Function JsonTokenGetChildCount%&(t As jsontok)
    JsonTokenGetChildCount%& = t.ChildrenIdxs.SIZE / 4
End Function

Function JsonTokenTotalChildren&(j As Json, idx As Long)
    Dim t As jsontok
    JsonGetToken j, idx, t

    JsonTokenTotalChildren& = _CV(_Integer64, _MK$(_Offset, t.ChildrenIdxs.SIZE / 4))
End Function

Function JsonTokenGetChild&(j As Json, idx As Long, childIdx As Long)
    Dim t As jsontok
    JsonGetToken j, idx, t

    JsonTokenGetChild& = ___JsonTokenGetChild&(t, childIdx)
End function

Function JsonTokenGetType&(j As Json, idx As Long)
    Dim t As jsontok
    JsonGetToken j, idx, t

    JsonTokenGetType& = t.typ
End Function

Function JsonGetEmptyToken&(j As Json)
    Dim b As JsonTokenBlock, t As jsontok
    ___JsonResetError

    If j.NextFree = -1 Then
        Dim m As _Mem
        j.TotalBlocks = j.TotalBlocks + 1

        m = _MemNew(j.TotalBlocks * Len(b))
        _MemCopy j.TokenBlocks, j.TokenBlocks.OFFSET, j.TokenBlocks.SIZE To m, m.OFFSET

        _MemFree j.TokenBlocks
        j.TokenBlocks = m

        JsonTokenBlockInit b, j.TotalBlocks - 1, j.NextFree
        _MemPut j.TokenBlocks, j.TokenBlocks.OFFSET + (j.TotalBlocks - 1) * Len(b), b
    End If

    res& = j.NextFree

    JsonGetToken j, j.NextFree, t

    j.NextFree = t.ParentIdx
    t.ParentIdx = 0

    JsonPutToken j, res&, t

    JsonGetEmptyToken& = res&
End Function

' FIXME: Mark all child tokens as well recursively
Sub JsonMarkEmptyToken(j As Json, idx As Long)
    Dim b As JsonTokenBlock, t As jsontok
    ___JsonResetError

    JsonGetToken j, idx, t

    t.typ = JSONTOK_TYPE_FREE
    t.ParentIdx = j.NextFree

    JsonPutToken j, idx, t

    j.NextFree = idx
End Sub

' FIXME: PRIVATE
Sub JsonGetToken(j As Json, idx As Long, t As jsontok)
    Dim b As JsonTokenBlock
    _MemGet j.TokenBlocks, j.TokenBlocks.OFFSET + _Shr(idx, JSON_BLOCK_SHIFT) * Len(b), b
    _MemGet b.m, b.m.OFFSET + (idx And (_Shl(1, JSON_BLOCK_SHIFT) - 1)) * Len(t), t
End Sub

' FIXME: PRIVATE
Sub JsonPutToken(j As Json, idx As Long, t As jsontok)
    Dim b As JsonTokenBlock
    _MemGet j.TokenBlocks, j.TokenBlocks.OFFSET + _Shr(idx, JSON_BLOCK_SHIFT) * Len(b), b
    _MemPut b.m, b.m.OFFSET + (idx And (_Shl(1, JSON_BLOCK_SHIFT) - 1)) * Len(t), t
End Sub

Function ___JsonEscapeString$(s As String)
    Dim res As String, i As Long

    For i = 1 To Len(s)
        Select Case Asc(s, i)
            Case 13: ' new line
                res = res + "\n"

            Case 10: ' Carriage Return
                res = res + "\r"

            Case 34: ' Double quote character
                res = res + "\" + Chr$(34)

            Case Asc("\"):
                res = res + "\\"

            Case 9: ' Tab
                res = res + "\t"

            Case 12: ' formfeed
                res = res + "\f"

            Case 8: ' Backspace
                res = res + "\b"

            Case Else:
                res = res + Chr$(Asc(s, i))
        End Select
    Next

    ___JsonEscapeString$ = res
End Function

Function ___JsonUnescapeString$(s As String)
    Dim res As String, i As Long, curIdx As Long
    curIdx = 1

    ' FIXME: Handle badly formatted strings
    Do
        i = Instr(curIdx, s, "\")
        If i = 0 Then
            res = res + MID$(s, curIdx)
            Exit Do
        End If

        res = res + MID$(s, curIdx, i - curIdx)

        Select Case Asc(s, i + 1)
            Case Asc("n"):
                res = res + Chr$(13)

            Case Asc("r"):
                res = res + Chr$(10)

            Case 34: ' Double quote
                res = res + chr$(34)

            Case Asc("\"):
                res = res + "\"

            Case Asc("t"):
                res = res + Chr$(9)

            Case Asc("f"):
                res = res + Chr$(12)

            Case Asc("b"):
                res = res + Chr$(8)

            Case Asc("/"):
                res = res + "/"

            Case Asc("u"):
                ' FIXME: Decode hex into UTF-8 sequence
        End Select

        curIdx = i + 2
    Loop

    ___JsonUnescapeString$ = res
End Function

Function ___JsonTokenCreatePrim&(j As Json, s As String, primTyp As _Byte)
    Dim idx As Long, t As jsontok
    idx = JsonGetEmptyToken&(j)

    JsonGetToken j, idx, t

    t.typ = JSONTOK_TYPE_VALUE
    t.primType = JSONTOK_PRIM_STRING

    t.value = _MemNew(Len(s))
    _MemPut t.value, t.value.OFFSET, s

    JsonPutToken j, idx, t

    ___JsonTokenCreatePrim& = idx
End Function

Function JsonTokenCreateString&(j As Json, s As String)
    ___JsonResetError
    JsonTokenCreateString& = ___JsonTokenCreatePrim&(j, ___JsonEscapeString$(s), JSONTOK_PRIM_STRING)
End Function

Function JsonTokenCreateBoolean&(j As Json, b As _Byte)
    Dim s As String
    ___JsonResetError
    If b Then s = "true" Else s = "false"

    JsonTokenCreateBoolean& = ___JsonTokenCreatePrim&(j, s, JSONTOK_PRIM_BOOL)
End Function

Function JsonTokenCreateInteger&(j As Json, i As _Integer64)
    ___JsonResetError
    JsonTokenCreateInteger& = ___JsonTokenCreatePrim&(j, LTRIM$(RTRIM$(STR$(i))), JSONTOK_PRIM_NUMBER)
End Function

Function JsonTokenCreateSingle&(j As Json, s As Double)
    ___JsonResetError
    JsonTokenCreateSingle& = ___JsonTokenCreatePrim&(j, LTRIM$(RTRIM$(STR$(s))), JSONTOK_PRIM_NUMBER)
End Function

Function JsonTokenCreateKey&(j As Json, k As String, inner As Long)
    Dim idx As Long, t As jsontok
    ___JsonResetError

    idx = JsonGetEmptyToken&(j)

    JsonGetToken j, idx, t

    t.typ = JSONTOK_TYPE_KEY

    t.value = _MemNew(Len(k))
    _MemPut t.value, t.value.OFFSET, k

    JsonTokenAddChild t, inner

    JsonPutToken j, idx, t

    JsonTokenCreateKey& = idx
End Function

Function JsonTokenCreateArray&(j As Json)
    Dim idx As Long, t As jsontok
    ___JsonResetError

    idx = JsonGetEmptyToken&(j)

    JsonGetToken j, idx, t

    t.typ = JSONTOK_TYPE_ARRAY

    JsonPutToken j, idx, t

    JsonTokenCreateArray& = idx
End Function

Sub JsonTokenArrayAdd(j As Json, arrayIdx As Long, childidx As Long)
    Dim t As jsontok
    ___JsonResetError

    JsonGetToken j, arrayIdx, t
    JsonTokenAddChild t, childidx
    JsonPutToken j, arrayIdx, t
End Sub

Function JsonTokenCreateObject&(j As Json)
    Dim idx As Long, t As jsontok
    ___JsonResetError

    idx = JsonGetEmptyToken&(j)

    JsonGetToken j, idx, t
    t.typ = JSONTOK_TYPE_OBJECT
    JsonPutToken j, idx, t

    JsonTokenCreateObject& = idx
End Function

Sub JsonTokenObjectAdd(j As Json, objectIdx As Long, childidx As Long)
    Dim t As jsontok
    ___JsonResetError

    JsonGetToken j, objectIdx, t
    JsonTokenAddChild t, childidx
    JsonPutToken j, objectIdx, t
End Sub

Sub JsonSetRootToken(j As json, idx As Long)
    ___JsonResetError

    j.RootToken = idx
End Sub

' FIXME: PRIVATE
Sub PrintTokens (json As String, j As json, index As Long, indent As Long)
    Dim t As jsontok
    JsonGetToken j, index, t

    Print Space$(indent); "Token"; index; " ("; t.startIdx; ","; t.endIdx; "), type: "; TokenTypeString$(t.typ); ", value: "; AddQuotes$(Mid$(json, t.startIdx, t.endIdx - t.startIdx + 1))
    ' Print Space$(indent); "- Value: "; 

    Dim i As _Offset, max As _Offset
    max = JsonTokenGetChildCount%&(t)

    while i < max
        PrintTokens json, j, ___JsonTokenGetChild(t, i), indent + 2
        i = i + 1
    Wend
End Sub

Function JsonRenderIndex$ (j As Json, idx As Long)
    Dim res As String, count As _Offset, i As _Offset, t As jsontok
    ___JsonResetError

    JsonGetToken j, idx, t

    SELECT CASE t.typ
        CASE JSONTOK_TYPE_OBJECT:
            res = "{"

            count = JsonTokenGetChildCount%&(t)
            While i < count
                res = res + JsonRenderIndex$(j, ___JsonTokenGetChild&(t, i))

                i = i + 1
                If i < count Then res = res + ","
            Wend

            res = res + "}"

        CASE JSONTOK_TYPE_ARRAY:
            res = "["

            count = JsonTokenGetChildCount%&(t)
            While i < count
                res = res + JsonRenderIndex$(j, ___JsonTokenGetChild&(t, i))

                i = i + 1
                If i < count Then res = res + ","
            Wend

            res = res + "]"

        CASE JSONTOK_TYPE_VALUE:
            SELECT CASE t.primType
                CASE JSONTOK_PRIM_STRING:
                    res = AddQuotes$(GetRawStrValue$(j, t))

                CASE JSONTOK_PRIM_NUMBER:
                CASE JSONTOK_PRIM_BOOL:
                CASE ELSE:
                    res = GetRawStrValue$(j, t)

            END SELECT

        CASE JSONTOK_TYPE_KEY:
            res = AddQuotes$(GetRawStrValue$(j, t)) + ":" + JsonRenderIndex$(j, ___JsonTokenGetChild&(t, 0))

    END SELECT

    JsonRenderIndex$ = res
End Function

Function JsonRender$ (j As json)
    JsonRender$ = JsonRenderIndex$(j, j.RootToken)
End Function

' FIXME: PRIVATE
Function GetRawStrValue$(j As json, t As jsontok)
    If t.value.OFFSET <> 0 Then
        Dim res as String

        res = Space$(t.value.SIZE)
        _MemGet t.value, t.value.OFFSET, res
        GetRawStrValue$ = res
    ElseIf j.origStr <> "" Then
        GetRawStrValue$ = Mid$(j.origStr, t.startIdx, t.endIdx - t.startIdx + 1)
    End If
End Function

' 'Function KeyEqual& (json As String, tokens() As jsontok, k As String, idx As Long)
' '
' 'End Function

' Returns the token index that the query refers too
Function JsonQueryFromToken&(j As Json, startToken As Long, query As String)
    Dim t As Long, tok As jsontok
    ___JsonResetError

    t = startToken

    While Len(query)
        Dim colon As Long, k As String, child As long
        colon = InStr(query, ":")

        If colon Then
            k = Mid$(query, 1, colon - 1)
            query = Mid$(query, colon + 1)
        Else
            k = query
            query = ""
        End If

        ' Array index
        If Asc(k, 1) = Asc("[") Then
            If Asc(k, Len(k)) <> Asc("]") Then ___JsonSetError JSON_ERR_BADQUERY, "Missing closing ]" : Exit Function
            Dim arrayIndex As Long
            arrayIndex = Val(Mid$(k, 2, Len(k) - 2))

            If arrayIndex < 0 Or arrayIndex >= JsonTokenTotalChildren&(j, t) Then ___JsonSetError JSON_ERR_OUTOFRANGE, "Array index out of range": Exit Function

            ' This is either a value, or an object inside the array
            t = JsonTokenGetChild&(j, t, arrayIndex)
        Else
            Dim found As Long
            found = 0

            For child = 0 To JsonTokenTotalChildren&(j, t) - 1
                Dim c As Long, typ As Long
                c = JsonTokenGetChild&(j, t, child)
                JsonGetToken j, c, tok

                If tok.typ <> JSONTOK_TYPE_KEY Then _Continue

                ' Print "Checking child"; child; ", value: "; AddQuotes$(GetStrValue$(json, tokens(), c)); ", check: "; k
                If GetRawStrValue$(j, tok) = k Then
                    found = JsonTokenGetChild&(j, c, 0) ' Get the child of the key node
                    Exit For
                End If
            Next

            If found = 0 Then ___JsonSetError JSON_ERR_KEYNOTFOUND, "Key " + AddQuotes$(k) + " not found!": Exit Function

            t = found
        End If
    Wend

    JsonQueryFromToken& = t
End Function

Function JsonQueryToken&(j As Json, query As String)
    JsonQueryToken& = JsonQueryFromToken&(j, j.RootToken, query)
End Function

' Returns the value of the token the query refers too
Function JsonQueryFromValue$ (j As Json, startToken As Long, query As String)
    Dim t As Long, tok As jsontok
    t = JsonQueryFromToken&(j, startToken, query)

    If t = 0 Then Exit Function

    JsonGetToken j, t, tok
    JsonQueryFromValue$ = GetRawStrValue$(j, tok)
End Function

' Returns the value of the token the query refers too
Function JsonQueryValue$ (j As Json, query As String)
    Dim t As Long, tok As jsontok
    t = JsonQueryToken&(j, query)

    If t = 0 Then Exit Function

    JsonGetToken j, t, tok
    JsonQueryValue$ = GetRawStrValue$(j, tok)
End Function

' FIXME: PRIVATE
Function TokenTypeString$(typ As _Byte)
    Select Case typ
        Case JSONTOK_TYPE_OBJECT: TokenTypeString$ = "Object"
        Case JSONTOK_TYPE_ARRAY: TokenTypeString$ = "Array"
        Case JSONTOK_TYPE_KEY: TokenTypeString$ = "Key"
        Case JSONTOK_TYPE_VALUE: TokenTypeString$ = "Value"
    End Select
End Function

' FIXME: 'PRIVATE'
Function FindEndingQuote~&(json As String, index As _Unsigned Long)
    Dim newIdx As _Unsigned Long
    For newIdx = index To Len(json)
        If Asc(json, newIdx) = 34 Then
            FindEndingQuote~& = newIdx
            Exit Function
        End If
    Next

    FindEndingQuote~& = 0
End Function

' FIXME: 'PRIVATE'
Function IsAlpha&(chr As Long)
    IsAlpha& = (chr >= Asc("a") And chr <= Asc("z")) Or (chr >= Asc("A") And chr <= Asc("Z"))
End Function

' FIXME: 'PRIVATE'
Function IsDigit&(chr As Long)
    IsDigit& = chr >= Asc("0") And chr <= Asc("9")
End Function

' FIXME: 'PRIVATE'
Function FindEndingWhitespace~&(json As String, index As _Unsigned Long)
    Dim newIdx As _Unsigned Long
    For newIdx = index To Len(json)
        Dim a As Long
        a = Asc(json, newIdx)
        If Not (IsAlpha&(a) Or IsDigit&(a)) Then
            FindEndingWhitespace~& = newIdx
            Exit Function
        End If
    Next

    FindEndingWhitespace~& = 0
End Function

' FIXME: PRIVATE
Sub ___JsonSetError(ero As Long, txt As String)
    JsonHadError = ero
    JsonError = txt
End Sub

Function JsonParse&(json As String, j As Json)
    Dim currentToken As Long, currentContainer As Long
    Dim curTok As jsontok, curCont As jsontok, prevTok As jsontok, tmpTok As jsontok
    ___JsonResetError

    If Not j.IsInitialized Then ___JsonSetError -1, "JSON object is not initialized": ParseJson& = 0: Exit Function

    j.OrigStr = json

    currentContainer = JsonGetEmptyToken&(j)
    currentToken = 0

    Dim strIdx As _Unsigned Long
    Dim lvl As Long
    lvl = 0

    For strIdx = 1 To Len(json)
        Dim chr As _Byte
        chr = Asc(json, strIdx)

        Dim nextToken As Long
        Dim endingQuote As _Unsigned Long

        Select Case chr
            Case Asc("{"), Asc("["):
                ' Start of an object
                currentToken = JsonGetEmptyToken&(j)

                JsonGetToken j, currentToken, curTok
                JsonGetToken j, currentContainer, curCont

                If chr = Asc("[") Then curTok.typ = JSONTOK_TYPE_ARRAY Else curTok.typ = JSONTOK_TYPE_OBJECT

                curTok.startIdx = strIdx
                curTok.ParentIdx = currentContainer

                if currentContainer <> currentToken Then JsonTokenAddChild curCont, currentToken

                ' Print Space$(lvl * 2); "New object, currentContainer: "; currentContainer; ", currentToken:"; currentToken; ", typ: "; curTok.typ
                JsonPutToken j, currentToken, curTok
                if currentContainer <> currentToken Then JsonPutToken j, currentContainer, curCont

                currentContainer = currentToken
                lvl = lvl + 1

            Case Asc("}"), Asc("]"):
                ' End of an object
                ' Print Space$(lvl * 2); "End object, currentContainer: "; currentContainer

                ' Find the object or array closest in the tree
                JsonGetToken j, currentContainer, curCont
                While curCont.typ <> JSONTOK_TYPE_OBJECT And curCont.typ <> JSONTOK_TYPE_ARRAY
                    currentContainer = curCont.ParentIdx
                    JsonGetToken j, currentContainer, curCont
                    ' Print Space$(lvl * 2); "type: "; curCont.typ; " cont:"; currentContainer
                    lvl = lvl - 1
                Wend

                If curCont.typ = JSONTOK_TYPE_ARRAY Then
                    '    Print "ending array!"
                    '    Sleep
                End If

                ' Print Space$(lvl * 2); "Search container: "; currentContainer; ", final container: "; curCont.ParentIdx
                curCont.endIdx = strIdx
                JsonPutToken j, currentContainer, curCont

                currentContainer = curCont.ParentIdx
                lvl = lvl - 1
                JsonGetToken j, currentContainer, curCont

                If curCont.typ = JSONTOK_TYPE_KEY Then currentContainer = curCont.ParentIdx: lvl = lvl - 1

            Case 34: ' Quote character
                prevToken = currentToken
                currentToken = JsonGetEmptyToken&(j)

                endingQuote = FindEndingQuote~&(json, strIdx + 1)
                ' Print Space$(lvl * 2); "Found quoted value, start:"; strIdx; ", end:"; endingQuote; ", currentToken:"; currentToken
                If endingQuote = 0 Then
                    ParseJson& = 0
                    Exit Function
                End If

                JsonGetToken j, prevToken, prevTok
                JsonGetToken j, currentToken, curTok
                JsonGetToken j, currentContainer, curCont

                If prevTok.typ <> JSONTOK_TYPE_KEY Then curTok.typ = JSONTOK_TYPE_KEY Else curTok.typ = JSONTOK_TYPE_VALUE
                curTok.startIdx = strIdx + 1
                curTok.endIdx = endingQuote - 1
                curTok.ParentIdx = currentContainer

                JsonTokenAddChild curCont, currentToken

                JsonPutToken j, currentToken, curTok
                JsonPutToken j, currentContainer, curCont
                ' Print Space$(lvl * 2); "currentToken typ:"; curTok.typ; ", currentContainer:"; curCont.typ

                If curTok.typ = JSONTOK_TYPE_KEY Then currentContainer = currentToken Else currentContainer = curCont.ParentIdx

                If curTok.typ = JSONTOK_TYPE_KEY Then
                    ' Print Space$(lvl * 2); "quoted value, v: "; GetStrValue$(json, tokens(), currentToken); ", Was key, parent: "; curCont.ParentIdx
                    lvl = lvl + 1
                Else
                    ' Print Space$(lvl * 2); "quoted value, v: "; GetStrValue$(json, tokens(), currentToken); ", Was value, parent: "; curCont.ParentIdx
                    lvl = lvl - 1
                End If
                ' Skips processing the end quote
                strIdx = endingQuote

            Case Asc("A") To Asc("Z"), Asc("a") To Asc("z"), Asc("0") To Asc("9"):
                ' Unquoted value
                currentToken = JsonGetEmptyToken&(j)

                endingQuote = FindEndingWhitespace~&(json, strIdx + 1)
                ' Print Space$(lvl * 2); "Found value, start:"; strIdx; ", end:"; endingQuote
                If endingQuote = 0 Then
                    ParseJson& = 0
                    Exit Function
                End If

                JsonGetToken j, currentToken, curTok
                JsonGetToken j, currentContainer, curCont

                curTok.typ = JSONTOK_TYPE_VALUE
                curTok.startIdx = strIdx
                curTok.endIdx = endingQuote - 1
                curTok.ParentIdx = currentContainer


                JsonTokenAddChild curCont, currentToken
                ' tokens(currentContainer).ChildrenIdxs = tokens(currentContainer).ChildrenIdxs + MKL$(currentToken)

                JsonPutToken j, currentToken, curTok
                JsonPutToken j, currentContainer, curCont

                '' Next Comma
                If curCont.typ <> JSONTOK_TYPE_ARRAY Then currentContainer = curCont.ParentIdx: lvl = lvl - 1

                ' subtract one to ensure we process the ending character
                strIdx = endingQuote - 1

            Case Asc(","):
                ' Commas get ignored, 
                ' Print Space$(lvl * 2); "comma, currentContainer:"; currentContainer;
                'currentContainer = tokens(currentContainer).ParentIdx
                'Print ", newContainer"; currentContainer
                'lvl = lvl - 1

            Case 32, 9, 10, 13: ' White space, ignored
        End Select
    Next

    'If lvl doesn't go back to zero, then an end brace or bracket was missing
    If lvl <> 0 Then
        ParseJson& = 0
    Else
        ParseJson& = -1
    End If
End Function

' FIXME: 'PRIVATE'
Function AddQuotes$ (s As String)
    AddQuotes$ = Chr$(34) + s + Chr$(34)
End Function
