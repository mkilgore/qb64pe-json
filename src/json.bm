'  Option _Explicit
'  
'  Screen _NewImage(1024, 800, 32)
'  
'  $Unstable:Http
'  Dim h&
'  Dim s$
'  Dim json$
'  
'  h& = _OpenClient("https://pokeapi.co/api/v2/pokemon/gallade")
'  
'  Print LOF(h&)
'  
'  While Not EOF(h&)
'      _Limit 100
'      Get h&, , s$
'      json$ = json$ + s$
'  Wend
'  
'  'PRINT LEN(json$)
'  'PRINT json$
'  
'  'OPEN "./result5.txt" FOR OUTPUT AS #5
'  'PRINT #5, json$
'  'CLOSE #5
'  
'  
'  ReDim tokens(100000) As jsontok
'  
'  ReDim _Preserve tokens(100001) As jsontok
'  
'  
'  ' json$ = "{" + AddQuotes$("key") + ": " + _
'  '            "{ " + AddQuotes$("key2") + ": true  , " + AddQuotes$("key3") + ": false }, " + _
'  '            "{ " + AddQuotes$("key7") + ": [ " + _
'  '                "{ " + AddQuotes$("key8") + ": false }, " + _
'  '                "{ " + AddQuotes$("key9") + ": false }, " + _
'  '                "{ " + AddQuotes$("key10") + ": false } " + _
'  '            "]," + _
'  '            AddQuotes$("key4") + ": true," + _
'  '            "{ " + AddQuotes$("key5") + ": true, " + AddQuotes$("key6") + ": false } " + _
'  '        "}"
'  
'  'json$ = "{ " + AddQuotes$("key") + " : true , " + AddQuotes$("k2") + " : " + _
'  '            "{ " + AddQuotes$("k3") + " : asdf, " + AddQuotes$("k4") + ":fffff }, " + _
'  '            AddQuotes$("k9") + " :" + _
'  '            "{ " + AddQuotes$("k3") + " : asdf, " + AddQuotes$("k4") + ":fffff } " + _
'  '        "}"
'  
'  
'  'Print json$
'  
'  Dim l As Long
'  l = ParseJson&(json$, tokens())
'  'Print "Parse result:"; l
'  
'  Dim g As String
'  Dim er As String
'  
'  Dim tok As Long
'  
'  tok = JsonQueryToken&(json$, tokens(), "moves:[30]:version_group_details:[3]:move_learn_method", er)
'  
'  g = JsonQueryFromValue$(json$, tokens(), tok, "name", er)
'  
'  'Sleep
'  Print "Error: "; er
'  Print "Value: "; g
'  
'  g = JsonQueryFromValue$(json$, tokens(), tok, "url", er)
'  
'  'Sleep
'  Print "Error: "; er
'  Print "Value: "; g
'  'Print "tok"
'  
'  
'  'PrintTokens json$, tokens(), 1, 0

Sub PrintTokens (json As String, tokens() As jsontok, index As Long, indent As Long)
    Dim t As jsontok
    t = tokens(index)

    Print Space$(indent); "Token"; index; " ("; t.startIdx; ","; t.endIdx; "), type: "; TokenTypeString$(t.typ); ", value: "; AddQuotes$(Mid$(json, t.startIdx, t.endIdx - t.startIdx + 1))
    ' Print Space$(indent); "- Value: "; 

    Dim i As Long
    For i = 1 To Len(t.ChildrenIdxs) / 4
        PrintTokens json, tokens(), CVL(Mid$(t.ChildrenIdxs, (i - 1) * 4 + 1, 4)), indent + 2
    Next
End Sub

'Function KeyEqual& (json As String, tokens() As jsontok, k As String, idx As Long)
'
'End Function

Function ChildCount& (tokens() As jsontok, idx As Long)
    ChildCount& = Len(tokens(idx).ChildrenIdxs) / 4
End Function

Function GetChild& (tokens() As jsontok, idx As Long, childIdx As Long)
    GetChild& = CVL(Mid$(tokens(idx).ChildrenIdxs, (childIdx - 1) * 4 + 1, 4))
End Function

' Returns the content of a token (Ex. Value, key name, object's string contents)
Function GetStrValue$ (json As String, tokens() As jsontok, idx As Long)
    GetStrValue$ = Mid$(json, tokens(idx).startIdx, tokens(idx).endIdx - tokens(idx).startIdx + 1)
End Function

' Returns the token index that the query refers too
Function JsonQueryFromToken& (json As String, tokens() As jsontok, startToken As Long, query As String, er As String)
    Dim t As Long
    t = startToken

    While Len(query)
        Dim colon As Long, k As String, child As long
        colon = InStr(query, ":")

        If colon Then
            k = Mid$(query, 1, colon - 1)
            query = Mid$(query, colon + 1)
        Else
            k = query
            query = ""
        End If

        ' Array index
        If Asc(k, 1) = Asc("[") Then
            If Asc(k, Len(k)) <> Asc("]") Then er = "ERROR: Index missing closing ]": Exit Function
            Dim arrayIndex As Long
            arrayIndex = Val(Mid$(k, 2, Len(k) - 2))

            If arrayIndex <= 0 Or arrayIndex > ChildCount&(tokens(), t) Then er = "ERROR: Array index out of range!": Exit Function

            ' This is either a value, or an object inside the array
            t = GetChild&(tokens(), t, arrayIndex)
        Else
            Dim found As Long
            For child = 1 To ChildCount&(tokens(), t)
                Dim c As Long
                c = GetChild&(tokens(), t, child)

                ' Print "Checking child"; child; ", value: "; AddQuotes$(GetStrValue$(json, tokens(), c)); ", check: "; k
                If GetStrValue$(json, tokens(), c) = k Then
                    found = GetChild&(tokens(), c, 1) ' Get the child of the key node
                    Exit For
                End If
            Next

            If found = 0 Then er = "ERROR: Key " + AddQuotes$(k) + " not found!": Exit Function

            t = found
        End If
    Wend

    JsonQueryFromToken& = t
End Function

Function JsonQueryToken& (json As String, tokens() As jsontok, query As String, er As String)
    JsonQueryToken& = JsonQueryFromToken&(json, tokens(), 1, query, er)
End Function

' Returns the value of the token the query refers too
Function JsonQueryFromValue$ (json As String, tokens() As jsontok, startToken As Long, query As String, er As String)
    Dim t As Long
    t = JsonQueryFromToken&(json, tokens(), startToken, query, er)
    If t Then JsonQueryFromValue$ = GetStrValue$(json, tokens(), t)
End Function

' Returns the value of the token the query refers too
Function JsonQueryValue$ (json As String, tokens() As jsontok, query As String, er As String)
    Dim t As Long
    t = JsonQueryToken&(json, tokens(), query, er)
    If t Then JsonQueryValue$ = GetStrValue$(json, tokens(), t)
End Function

Function TokenTypeString$ (typ As _Byte)
    Select Case typ
        Case JSONTOK_TYPE_OBJECT: TokenTypeString$ = "Object"
        Case JSONTOK_TYPE_ARRAY: TokenTypeString$ = "Array"
        Case JSONTOK_TYPE_KEY: TokenTypeString$ = "Key"
        Case JSONTOK_TYPE_VALUE: TokenTypeString$ = "Value"
    End Select
End Function

Function FindEndingQuote~& (json As String, index As _Unsigned Long)
    Dim newIdx As _Unsigned Long
    For newIdx = index To Len(json)
        If Asc(json, newIdx) = 34 Then
            FindEndingQuote~& = newIdx
            Exit Function
        End If
    Next

    FindEndingQuote~& = 0
End Function

Function IsAlpha& (chr As Long)
    IsAlpha& = (chr >= Asc("a") And chr <= Asc("z")) Or (chr >= Asc("A") And chr <= Asc("Z"))
End Function

Function IsDigit& (chr As Long)
    IsDigit& = chr >= Asc("0") And chr <= Asc("9")
End Function

Function FindEndingWhitespace~& (json As String, index As _Unsigned Long)
    Dim newIdx As _Unsigned Long
    For newIdx = index To Len(json)
        Dim a As Long
        a = Asc(json, newIdx)
        If Not (IsAlpha&(a) Or IsDigit&(a)) Then
            FindEndingWhitespace~& = newIdx
            Exit Function
        End If
    Next

    FindEndingWhitespace~& = 0
End Function

Function ParseJson& (json As String, tokens() As jsontok)
    Dim currentToken As Long, currentContainer As Long
    currentToken = 0
    currentContainer = 0
    Dim strIdx As _Unsigned Long
    Dim lvl As Long
    lvl = 0

    For strIdx = 1 To Len(json)
        Dim chr As _Byte
        chr = Asc(json, strIdx)

        Dim nextToken As Long
        Dim endingQuote As _Unsigned Long

        Select Case chr
            Case Asc("{"), Asc("["):
                ' Start of an object
                currentToken = currentToken + 1

                If chr = Asc("[") Then tokens(currentToken).typ = JSONTOK_TYPE_ARRAY Else tokens(currentToken).typ = JSONTOK_TYPE_OBJECT

                tokens(currentToken).startIdx = strIdx
                tokens(currentToken).ParentIdx = currentContainer

                tokens(currentContainer).ChildrenIdxs = tokens(currentContainer).ChildrenIdxs + MKL$(currentToken)

                'Print Space$(lvl * 2); "New object, currentContainer: "; currentContainer; ", currentToken:"; currentToken
                currentContainer = currentToken
                lvl = lvl + 1

            Case Asc("}"), Asc("]"):
                ' End of an object
                ' Print Space$(lvl * 2); "End object, currentContainer: "; currentContainer

                ' Find the object or array closest in the tree
                While tokens(currentContainer).typ <> JSONTOK_TYPE_OBJECT And tokens(currentContainer).typ <> JSONTOK_TYPE_ARRAY
                    currentContainer = tokens(currentContainer).ParentIdx
                    lvl = lvl - 1
                Wend

                If tokens(currentContainer).typ = JSONTOK_TYPE_ARRAY Then
                    '    Print "ending array!"
                    '    Sleep
                End If

                'Print Space$(lvl * 2); "Search container: "; currentContainer; ", final container: "; tokens(currentContainer).ParentIdx
                tokens(currentContainer).endIdx = strIdx
                currentContainer = tokens(currentContainer).ParentIdx
                lvl = lvl - 1

                If tokens(currentContainer).typ = JSONTOK_TYPE_KEY Then currentContainer = tokens(currentContainer).ParentIdx: lvl = lvl - 1

            Case 34: ' Quote character
                currentToken = currentToken + 1

                endingQuote = FindEndingQuote~&(json, strIdx + 1)
                'Print Space$(lvl * 2); "Found quoted value, start:"; strIdx; ", end:"; endingQuote
                If endingQuote = 0 Then
                    ParseJson& = 0
                    Exit Function
                End If

                If tokens(currentToken - 1).typ <> JSONTOK_TYPE_KEY Then tokens(currentToken).typ = JSONTOK_TYPE_KEY Else tokens(currentToken).typ = JSONTOK_TYPE_VALUE
                tokens(currentToken).startIdx = strIdx + 1
                tokens(currentToken).endIdx = endingQuote - 1
                tokens(currentToken).ParentIdx = currentContainer

                tokens(currentContainer).ChildrenIdxs = tokens(currentContainer).ChildrenIdxs + MKL$(currentToken)

                If tokens(currentToken).typ = JSONTOK_TYPE_KEY Then currentContainer = currentToken Else currentContainer = tokens(currentContainer).ParentIdx
                If tokens(currentToken).typ = JSONTOK_TYPE_KEY Then
                    'Print Space$(lvl * 2); "quoted value, v: "; GetStrValue$(json, tokens(), currentToken); ", Was key, parent: "; tokens(currentToken).ParentIdx
                    lvl = lvl + 1
                Else
                    'Print Space$(lvl * 2); "quoted value, v: "; GetStrValue$(json, tokens(), currentToken); ", Was value, parent: "; tokens(currentToken).ParentIdx
                    lvl = lvl - 1
                End If
                ' Skips processing the end quote
                strIdx = endingQuote

            Case Asc("A") To Asc("Z"), Asc("a") To Asc("z"), Asc("0") To Asc("9"):
                ' Unquoted value
                currentToken = currentToken + 1

                endingQuote = FindEndingWhitespace~&(json, strIdx + 1)
                'Print Space$(lvl * 2); "Found value, start:"; strIdx; ", end:"; endingQuote
                If endingQuote = 0 Then
                    ParseJson& = 0
                    Exit Function
                End If

                tokens(currentToken).typ = JSONTOK_TYPE_VALUE
                tokens(currentToken).startIdx = strIdx
                tokens(currentToken).endIdx = endingQuote - 1
                tokens(currentToken).ParentIdx = currentContainer

                tokens(currentContainer).ChildrenIdxs = tokens(currentContainer).ChildrenIdxs + MKL$(currentToken)

                '' Next Comma
                If tokens(currentContainer).typ <> JSONTOK_TYPE_ARRAY Then currentContainer = tokens(currentContainer).ParentIdx: lvl = lvl - 1

                ' subtract one to ensure we process the ending character
                strIdx = endingQuote - 1

            Case Asc(","):
                'Print Space$(lvl * 2); "comma, currentContainer:"; currentContainer;
                'currentContainer = tokens(currentContainer).ParentIdx
                'Print ", newContainer"; currentContainer
                'lvl = lvl - 1

            Case 32, 9, 10, 13: ' White space, ignored
        End Select
    Next

    ParseJson& = -1
End Function

Function AddQuotes$ (s As String)
    AddQuotes$ = Chr$(34) + s + Chr$(34)
End Function
